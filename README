simple-peg

A simple parsing expression grammar (PEG) defined parser generator

Designed to be simple and flexible

At the moment, this release is alpha, currently debugging PEGs with
cycles.

Was inspired by CL-PPCRE. I tried to structure the code to generate a
tree of closures as described by Xach
http://xach.livejournal.com/131456.html

USAGE:

The intent is to create an S-expression like description of the
PEG. The abstract syntax tree is just sequences with :keywords as the
operators. I've defined a set of helper macros/functions to make it
easier to succicntly describe the PEG while retaining the full power
of clojure. Because the PEG is defined by sequences, it should be easy
to extend this code to make a regexp looking version on top of it.

So simply pass the PEG description to make-parser in a let like
binding form.

(let [x (make-parser [A (s \a (o A) \b)
         	      B (s \b (o B) \c)
		      S (s (a-p? (s A \c)) (o-o-m \a) B (n-p? (o-c \a \b \c)))])]
  (x '(\a \b \c))

make-parser returns a parser function defined by the last binding form
(in the example, S). The parser takes a sequence and returns any
unparsed content. So this also means that, if it returns (), the empty
sequence, the parser succeeded. The parser will return nil if it fails.

Unfortunetly, the parser fails on PEGs defined with cycles (like in
the example) and I haven't created robust tests yet but I'm going in
the spirit that if you feel ready to release, you released it too
late.

Please send me critiques, advice, or patches.

License

Copyright (C) 2009-2010 Brent Millare

This file is licensed under the terms of the GNU General Public
License as distributed with Emacs (press C-h C-c to view it)